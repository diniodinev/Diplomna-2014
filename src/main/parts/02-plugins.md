## Плъгини
Системата позволява да бъдат създадени собствени плъгини. Те разширяват възможностите й и позволяват една функционалност
(тази описана в плъгина) да бъде използвана на много различни места. Плъгините на системата не са разработени като отделни външни артефакти, 
т.е. те може да бъдат използвани само в конкретния проект.
### Същност
Плъгинът е разширение на Gradle, което конфигурира проекта по някакъв начин, обикновено това става чрез добавяне на преварително 
конфигурирани таскове (задачи), които заедно извършват някаква работа. Gradle се разпространява с определен набор от плъгини, 
които лесно могат да бъдат разширени (extend-нати) или да бъдат създадени нови такива. 
В системата те се намират в директорията __buildSrc__. Това е така поради особеността на изпълнение на билда в _Gradle_.
Преди да започне самото резолване на зависимостите и билдване на сорскода от __src__ директорията например, се извършва 
билдване на съдържанието на __buildSrc__ директорията, т.е. преди започване на същинското билдване плъгините, които ние 
сме създали, са билднати успешно и са достъпни за нашия код.
 
### Структура на buildSrc 
Директорията __buildSrc__ представлява сама по себе си многомодулен проект. Тя се състои от специално създадените разширения, които
са предназначени за целите на различните предмети, в които ще се използват. Те са разположени в __plugins__. Освен това в __buildSrc__ 
се намират и други плъгини, които имат помощни функции за системата, 
а не са специално направени за извършване на проверки или оценки по даден предмет (основна функция на системата). Плъгините могат да се използват и композират 
в разширения, които да служат за проверка от преподавателите.
За да бъде създадено ново разширение, то трябва да се спазват [Gradle конвенциите](http://www.gradle.org/docs/current/userguide/custom_plugins.html) и препоръките за неговото разработване.
 
  
###Налични Плъгини
__FMIJavaPlugin__ разширява вградения __JavaPlugin__, като добавя няколко таска, свързани с разархивиране, изтриване на проектни артефакти. Освен това той включва всички таскове на своя предшественик - таскове за компилиране, изпълнение на unit тестове и билдване на __Jar__ файлове.

__FMIJavaPlugin__ е базиран на конвенции. Това означава, че в много от случаите плъгинът задава стойности по подразбиране на повечето свойства на проекта, като например директорията, в която ще бъдат разархивирани проектните артефакти. Ако се спазват тези конвенции, от потребителя не се изисква много работа за извършване на конфигурация на плъгина. Но, от друга страна, се дава възможност и за конфигурирането на плъгините спрямо нуждите на потребителя.

За да използвате __FMIJavaPlugin__ във вашия билд:

__oop.gradle__

	apply plugin: 'fmi-java'

#### Типове таскове
Плъгинът предоставя няколко типа задачи. Един от тях е __getInfo__, който позволява да се извърши извличане на необходимите файлове (проектни архиви, които трябва да се проверяват), тяхното разпакетиране, както и създаване на нов [sourceSet](#http://www.gradle.org/docs/current/userguide/java_plugin.html#N11E60) за всеки отделен проект. 
За да можете да използвате таска __getInfo__, трябва да конфигурирате задължителните му свойства:

__свойства:__

__courseName__ (избираемо): името на курса, за който ще се отнася този таск. Това свойство не е задължително, ако се пропусне, за име на курс се взима стойността на системното свойство __conf__.

__outputDir__ (избираемо): директорията, в която ще се разархивират файловете. Това свойство също не е задължително, ако се пропусне, за изходна директория на сорс кода се взима __src__ директорията и там те се разархивират.

__sourceFiles__(задължително): колекция от файлове или директории, в които са поместени различните артефакти, които ще се разархивират и проверяват.

__oop.gradle__

	apply plugin: 'fmi-java'

	getInfo {
		courseName = "OOP_Java"
		sourceFiles = files(/C:\main\resources/)
		outputDir= "bin"
	}

След това можете да изпозлвате: 

    ./gradlew -Pconf=oop getInfo

Освен него плъгинът разполага и със задачата __uploadDropbox__, която извършва качване на посочени файлове в определен __DropBox__ акаунт.

__свойства:__

__authFile__ (задължително): пътят до файла, в който се намира __token__ за __DropBox__ акаунта, в който ще се качват файловете.

__localFilesToUpload__ (задължително): пътят до файла или файловете, които ще се качват.

Всеки файл, който се качва, се upload-ва в уникална директория във формат 'yyyy-MM-dd-kk-mm-ss'

__Важно__
Тъй като _токенът_ позволява обмяна на файлове към __Dropbox__ акаунт без да е необходима друга аутентикация, е препоръчително той
да се съхранява на сигурно място. Поради тази причина е добре да се създаде променлива, която да се добави в 

	userhome/.gradle/gradle.properties 
	
След това задачата __uploadDropbox__ може да се конфигурира посредством използване на името на променливата. Чрез ограничаване на достъпа до __gradle.properties__ файла
на машината, върху която се извършват билдовете, ще се позволи да се използва даденият __token__ , но само в рамките на системата,
без право да се вижда, променя или копира. За повече информация [тук](http://www.gradle.org/docs/current/userguide/tutorial_this_and_that.html)

	uploadDropbox {
		authFile = TOKEN
		localFilesToUpload "${project.buildDir}\\reports"
	}

Където TOKEN е име на свойство, дефинирано в properties файл, а __localFilesToUpload__ посочва, че директорията __reports__ трябва да се качи.

__deleteSrc__ е името на друга задача, която плъгинът предоставя. Тя изтрива всички изходни файлове от getInfo задачата.

__sendEmail__ е таскът, който позволява изпращане на email съобщения.

__свойства__:

__message__ (избираемо) съдържанието на съобщението

__subject__ (задължително) заглавието на съобщението

__toAddress__ (задължително) единичен адрес или множество адреси, разделени с ";", към които ще се изпраща съобщението

__host__ (задължително) име на host

__port__ (задължително) номер на port

От съответния конфигурационен файл, в който се използва плъгинът, трябва да се посочат стойности на задължителните полета н.р.:

	sendEmail {
	    message = "Your code has been checked."
		subject = "Results"
		toAddress = "person123456@gmail.com;person9876@gmail.com"
		host = "smtp.gmail.com"
		port = "587"
	}

__FMI Essay plugin__

Плъгинът позволява извършване на базови проверки върху html файлове, както и генериране на QR кодове и обединяването им в pdf.

**Начин на използване**

	aplly plugin: 'fmi-essay'

***Задачи***

**essaysCheck** Основната цел на задачaта е от подадени source файлове, да вземе необходимият текст и да генерира отчет за това, колко: страници, изречения и думи съдържа в даденото есе, hmtl страница или реферат и да се определи до каква степен студентите са положили усиля за тяхното създаване.

	essaysCheck {
	    inputEncoding = "UTF-8"
	    outputEncoding = "UTF-16"
	    wordLength = 3
	    sentanceLength = 3
	    wordsPerPage = 250
	    symbolsPerPage = 2550
	    source = unzip.outputs.files
	}

Задачата съдържа следните свойства, всички те са задължителни:

***inputEncoding*** - Encoding на файловете за проверка.

***outputEncoding*** - Encoding на изходните файлове.

***wordLength*** - Дължина на дума. Показва над колко броя дадено обединение на символи се счита за дума.

***sentanceLength*** - Брой на думи на изречение. Над колко броя, дадено обединение на думи се счита за изречение.

***symbolsPerPage*** - Брой символи на страница. Показва колко броя символи се считат за страница.

***source*** - Входни файлове за проверка.

***reportPath*** - (опционално свойство) подразбиращата се стойност на полето е buildDir/reports/essays/, тя показва къде ще се генерира отчета от проверката.


----------

***unzip*** - задача, която разархивира посочени zip архиви

	unzip {
	    sourceFiles = files(file("src/main/resources/essay"))
	    outputDir = project.file("src/essaysP")
	}

Тя има следните свойства:

***sourceFiles*** (задължително) - входни файлове.

***outputDir*** (избираемо)  - директория, където ще бъдат разархивирани файловете. Стойността по подразбиране е 'src'

----------

***essaysClean*** - задача, която изтрива изходните файлове от unzip задачата, ако unzip задачата не е конфигуриране предварително то essaysClean не прави нищо.

----------

***generateQRFromFiles*** - задача, която генерира QR файлове от посочени текстови файлове. Съдържанието на текстовите файлове се взима и на негова база се генерират QR кодове. Методът не гарантира правилното генериране на код от файл съдържащ над ***900*** символа.

	generateQRFromFiles {
	     outputQRPath = new File(project.rootProject.buildDir, "QRs")
	    inputEncoding = "UTF-8"
	    source = zipTree(project.file(project.rootDir).path + "/src/main/resources/problems/problems_qr.zip")
	    imageType = "jpg"
	}

задачата има следните свойства:

-  ***inputEncoding*** (избираемо) - Encoding на файловете, от които ще се вземе текста. Подразбиращият се е UTF-8.
-  ***source*** (задължително) - входни файлове, за които ще бъдат генерирани QR кодове
-  ***imageType*** (избираемо) - тип на генерираните изходни файлове. Подразбиращият се тип е ***png***.
-  ***outputEncoding*** (избираемо) - Encoding на текста в генерираните QR файлове. 
-  ***outputQRPath*** (избираемо) - директорията, в която ше се генерират QR файловете. Подразбиращата се стойност е ***build/essays/QR***
-  ***pictureHeight*** (избираемо) - височината на QR кодът, който ще се генерира. Подразбиращата се стойнсот е  100 пиксела.
-  ***pictureWidth*** (избираемо) - широчината на QR кодът, който ще се генерира. Подразбиращата се стойнсот е  100 пиксела.

----------

***generateQRFromText*** - задача, която генерира QR кодове от посочен текст. Тя наследява абстрактния клас GenerateQRTask, като добавя ново свойство QRInfo - Map, съдържаща *[<текст в QR>:<име на генериран QR файл>]*

	generateQRFromText {
	    QRInfo = ["Група 1": "Group1_QR_Info", "Група 2  задачи. Problems": "Group2_QR_Info", "Problems": "Group3_QR_Info"]
	}
 
След изпълнението на задачата ще се генерират три файла съответно с имена:
Group1_QR_Info.png, Group2_QR_Info.png , Group3_QR_Info.png, които ще съдържат съответно в QR кода си текст, *Група 1*, *задачи. Problems*, *Problems*.

----------

***generateQRVcardFromText*** - задача, която генерира QRVCard. Тя наследява абстрактния клас GenerateQRTask. Освен това дефинира следните свойства:

-  ***vCardFileName*** (избираемо) - свойство със стойност по подразбиране vCardQR. То задава името на файла, който ще се генерира. В случая ако не се специфицира друго ще е vCardQR.png.
-  ***company*** (избираемо) - име на компания, в която работи даденото лице
-  ***title*** (избираемо) - титла на даденото лице
-  ***phonenumber*** (избираемо) - телефонен номер на описваното лице
-  ***email*** (избираемо) - електронна поща на описваното лице.
-  ***address*** (избираемо) - адрес на описваното лице.
-  ***website*** (избираемо) -  сайт на описваното лице.

----------

***generatePDF*** - задача, която генерира pdf документ с определени QR изображения. Тя наследява [SourceTask](http://www.gradle.org/docs/current/javadoc/org/gradle/api/tasks/SourceTask.html) и дефинира следните свойства:

-  ***source*** (задълцително) - специфицира от къде да бъдат взети QR изображенията, за да се генирира pdf-a. 
-  ***pageTitle*** (избираемо) - заглавие, което да се появи на началната страница на pdf-a.
-  ***pdfFileName*** (избираемо) - име на файла, който ще се генерира. Ако стойност не се посочи подразбиращата се е:  *generatedPdf.pdf*
-  ***outputPDFPath*** (избираемо) - директорията, в която ще се генерира pdf. Ако стойност не се посочи на това свойство, подразбиращата се е ***build/essays/pdf***
-  ***picturesPerRow*** (избираемо) - брой QR изображения на ред. Подразбиращата се стойнсот е 1
-  ***repeatTimes*** (избираемо) - показва колко пъти избраните QR изображения ще се повторят в генерирания изходен pdf. Подразбиращата се стойност е 1.
-  ***useDefaultFonts*** (избираемо) - boolean свойство, което показва дали трябва да се използва подразбиращият се шрифт за генериране на заглавие. Стойността му ако не се промени е true и за генериране за заглавието на pdf се използва шрифта ***'Azbuka04.ttf'***. Ако стойността му се промени, то този подразбиращ се шрифт не се използва.
-  ***fontToRegister*** (избираемо) - Map <път до шрифт:име на шрифт>. Позволява регистрирането на нов шрифт, който да бъде използван за генерирането на заглавието.

	
		generatePDF {
		    pageTitle = "Групи за задачите. Problems for the groups"
		    source = generateQRFromText.outputs.files
		    picturesPerRow = 6
		    repeatTimes = 100
		    useDefaultFonts = false
		    fontToRegister = ["${project.rootDir}/src/main/style/fonts/Mangalian.ttf": 'Mangalian.ttf']
		}