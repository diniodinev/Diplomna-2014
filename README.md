<img src="http://students.uni-sofia.bg/wp/wp-content/uploads/2010/11/logo-su-s-nadpis.jpg"/>

# Система за автоматизирано подпомагане на обучението в курсовете по програмиране

## Цел

Целта на дипломната работа е създаване на Contininuous Integration система за автоматизирано подпомагане на обучението в курсовете по програмиране в Софийския университет "Св. Климент Охридски"

## Билдване

За билдването на системата се изпозлва билд тулът Gradle. Той осигурява иновативен начин [wrapper](http://gradle.org/docs/current/userguide/gradle_wrapper.html), който позволява да се работи с Gradle билдове без да е необходима ръчна инсталация. Wrapper е batch скрипт за Windows и shell скрипт за другите операционни системи.

Желателно е да се използва wrapper за билдване на Gradle базирани проекти. Като цяло, използването му гарантира, че за билда ще се използва тази версия на Gradle, която е необходима.

### Конфигуриране 

Системата дава лесна възмонжост за избиране на конфигурационен файл, чрез който да се настроят необходимите характеристики на проекта.

<img src="http://195.149.248.189:8080/2014-03-12/3b799fcee24b2c4dd348d66eaa30164d_245x114.jpg" width="245px" height="114px" class="inlinePic"/>

#####Именуване
Тези конфигурационни файлове <име>.gradle са Gradle билд скриптове и за тях важат всички правила, които се отнасят за другите Groovy скритове.  Желателно е <име> да е името на курса, чийто конфигуриране ще искаме да извършим.
Тези скриптове трябва да се създадат предварително от потребителя и трябва да бъдат поставени в:

    Project/config/specifications

#####Стартиране
За да бъдат използвани при стартиране на билд, името на желания скрипт трябва да се подаде като __system property__
Това може да бъде извършено чрез: 

    ./gradlew -Pconf=example command1 command2

__conf__ е името на системната променлива, а example е името на скриптовия файл, описан в [Именуване](#Именуване).
```text
    Ако не специфицирате стойност на системната променлива conf, ще бъде взет default.gradle скриптът.
```


## Плъгини
Системата позволява да бъдат създадени собствени плъгини. Те разширяват възможностите й и позволяват една функционалност
(тази описана в плъгина) да бъде използвана на много различни места. Плъгините на системата не са разработени като отделни външни артефакти, 
т.е. те може да бъдат използвани само в конкретния проект.
### Същност
Плъгинът е разширение на Gradle, което конфигурира проекта по някакъв начин, обикновено това става чрез добавяне на преварително 
конфигурирани таскове (задачи), които заедно извършват някаква работа. Gradle се разпространява с определен набор от плъгини, 
които лесно могат да бъдат разширени (extend-нати) или да бъдат създадени нови такива. 
В системата те се намират в директорията __buildSrc__. Това е така поради особеността на изпълнение на билда в _Gradle_.
Преди да започне самото резолване на зависимостите и билдване на сорскода от __src__ директорията например, се извършва 
билдване на съдържанието на __buildSrc__ директорията, т.е. преди започване на същинското билдване плъгините, които ние 
сме създали, са билднати успешно и са достъпни за нашия код.
 
### Структура на buildSrc 
Директорията __buildSrc__ представлява сама по себе си многомодулен проект. Тя се състои от специално създадените разширения, които
са предназначени за целите на различните предмети, в които ще се използват. Те са разположени в __plugins__. Освен това в __buildSrc__ 
се намират и други плъгини, които имат помощни функции за системата, 
а не са специално направени за извършване на проверки или оценки по даден предмет (основна функция на системата). Плъгините могат да се използват и композират 
в разширения, които да служат за проверка от преподавателите.
За да бъде създадено ново разширение, то трябва да се спазват [Gradle конвенциите](http://www.gradle.org/docs/current/userguide/custom_plugins.html) и препоръките за неговото разработване.
 
  
###Налични Плъгини
__FMIJavaPlugin__ разширява вградения __JavaPlugin__, като добавя няколко таска, свързани с разархивиране, изтриване на проектни артефакти. Освен това той включва всички таскове на своя предшественик - таскове за компилиране, изпълнение на unit тестове и билдване на __Jar__ файлове.

__FMIJavaPlugin__ е базиран на конвенции. Това означава, че в много от случаите плъгинът задава стойности по подразбиране на повечето свойства на проекта, като например директорията, в която ще бъдат разархивирани проектните артефакти. Ако се спазват тези конвенции, от потребителя не се изисква много работа за извършване на конфигурация на плъгина. Но, от друга страна, се дава възможност и за конфигурирането на плъгините спрямо нуждите на потребителя.

За да използвате __FMIJavaPlugin__ във вашия билд:

__oop.gradle__

	apply plugin: 'fmi-java'

#### Типове таскове
Плъгинът предоставя няколко типа задачи. Един от тях е __getInfo__, който позволява да се извърши извличане на необходимите файлове (проектни архиви, които трябва да се проверяват), тяхното разпакетиране, както и създаване на нов [sourceSet](#http://www.gradle.org/docs/current/userguide/java_plugin.html#N11E60) за всеки отделен проект. 
За да можете да използвате таска __getInfo__, трябва да конфигурирате задължителните му свойства:

__свойства:__

__courseName__ (избираемо): името на курса, за който ще се отнася този таск. Това свойство не е задължително, ако се пропусне, за име на курс се взима стойността на системното свойство __conf__.

__outputDir__ (избираемо): директорията, в която ще се разархивират файловете. Това свойство също не е задължително, ако се пропусне, за изходна директория на сорс кода се взима __src__ директорията и там те се разархивират.

__sourceFiles__(задължително): колекция от файлове или директории, в които са поместени различните артефакти, които ще се разархивират и проверяват.

__oop.gradle__

	apply plugin: 'fmi-java'

	getInfo {
		courseName = "OOP_Java"
		sourceFiles = files(/C:\main\resources/)
		outputDir= "bin"
	}

След това можете да изпозлвате: 

    ./gradlew -Pconf=oop getInfo

Освен него плъгинът разполага и със задачата __uploadDropbox__, която извършва качване на посочени файлове в определен __DropBox__ акаунт.

__свойства:__

__authFile__ (задължително): пътят до файла, в който се намира __token__ за __DropBox__ акаунта, в който ще се качват файловете.

__localFilesToUpload__ (задължително): пътят до файла или файловете, които ще се качват.

Всеки файл, който се качва, се upload-ва в уникална директория във формат 'yyyy-MM-dd-kk-mm-ss'

__Важно__
Тъй като _токенът_ позволява обмяна на файлове към __Dropbox__ акаунт без да е необходима друга аутентикация, е препоръчително той
да се съхранява на сигурно място. Поради тази причина е добре да се създаде променлива, която да се добави в 

	userhome/.gradle/gradle.properties 
	
След това задачата __uploadDropbox__ може да се конфигурира посредством използване на името на променливата. Чрез ограничаване на достъпа до __gradle.properties__ файла
на машината, върху която се извършват билдовете, ще се позволи да се използва даденият __token__ , но само в рамките на системата,
без право да се вижда, променя или копира. За повече информация [тук](http://www.gradle.org/docs/current/userguide/tutorial_this_and_that.html)

	uploadDropbox {
		authFile = TOKEN
		localFilesToUpload "${project.buildDir}\\reports"
	}

Където TOKEN е име на свойство, дефинирано в properties файл, а __localFilesToUpload__ посочва, че директорията __reports__ трябва да се качи.

__deleteSrc__ е името на друга задача, която плъгинът предоставя. Тя изтрива всички изходни файлове от getInfo задачата.

__sendEmail__ е таскът, който позволява изпращане на email съобщения.

__свойства__:

__message__ (избираемо) съдържанието на съобщението

__subject__ (задължително) заглавието на съобщението

__toAddress__ (задължително) единичен адрес или множество адреси, разделени с ";", към които ще се изпраща съобщението

__host__ (задължително) име на host

__port__ (задължително) номер на port

От съответния конфигурационен файл, в който се използва плъгинът, трябва да се посочат стойности на задължителните полета н.р.:

	sendEmail {
	    message = "Your code has been checked."
		subject = "Results"
		toAddress = "person123456@gmail.com;person9876@gmail.com"
		host = "smtp.gmail.com"
		port = "587"
	}


### Документация

Документацията на системата служи за подпомагане и улесняване на потребителите, които я използват. За да бъде генерирана документацията,
не е необходимо да се посочват никакви други допълнителни конфигурационни файлове или системни свойства __system property__.
Генериране на документацията по време на изпълнението се осъществява чрез изпълняването на командата:

	./gradlew baseHtml

След успешно генериране ще се изведе следният изход:

	:copyStyles
	:concatPartsMd
	:rawHtml
	:baseHtml
	 Documentation is generated in:
	/Project/build/html/baseHtml.html

След това тя ще може да бъде достъпена при отвяряне на __baseHtml.html__ файла.

#### Начин на генериране на документацията
Документацията се състои от информация, която описва различни системни функционалности и как те да бъдат конфигурирани и настройвани.
Цялата информация трябва да бъде въведена в текстов вид. Това става чрез описанието й в: [markdown](http://daringfireball.net/projects/markdown/) формат и съхраняването й в: 
	
	project/src/main/parts/number-description.md
	
където __number__ е последователен номер, показващ къде даденият __markdown__ файл ще се разположи, а __description__ е значещо име, описващо съдържанието 
на файла. 
Всички файлове с разширение __md__ се обединяват в един общ файл __parts.md__, който се разполага в __buildDir/parts.md__, където
__buildDir__ е името на специфицираната билд директория за проекта.
След като бъдат обединени файловете по лексикографски ред в един общ файл, от тях се извършват преобразувания и се генерира изходният __BaseHtml.html__
Освен това при генерирането се извършва и копиране на __css__ файловете и необходимите шрифтове за документацията. Тяхното първоначално местонахождение е
в: 

	project/src/style
	
Начинът, по който се извършва трансформацията от _md_ файл в _html_ е описана в: 

	project/src/main/transforms/base.groovy
	
Цялата логика и стъпките за генериране на документацията са разположени в:
	
	project/config/docs.gradle

Част от функционалностите за генериране и преобразуване са изведени в самостоятелни приставки, които може да бъдат използвани отново. Това са намиращите 
се в _buildSrc_ разширения - _jsoup_, _pegdown_, _xhtmlrenderer_.
	




### Как да създадем нов плъгин
Създаването на нов плъгин не е трудно и изизква научаването на няколко нови концепции. Gradle позвоялва създаването на два вида разширения (plugins) - скриптови и обектни. 

- Скриптови - не представляват нищо повече от скриптов файл(build.gradle), който е импортнат в друг скриптов файл
- Обектните - за тях е необходимо да се имплементира *org.gradle.api.Plugin* интерфейса. Сорс кода на обектните плъгини обикновенно се съдържа в buildSrc директорията или в отделен проект и след това може да се дистрибутира като *Jar* файл.

В тази част ще разгледаме как се създава само обектен плъгин, което ще бъде от полза при разширяването на функционалностите на системата.

#### Основни характеристики при разработването на обектен плъгин
- Gradle дава пълната свобода да изберем как ще го имплементираме - дали ще създадем отделен проект за нашето разширение, дали ще го разположим в билд скриптов файл или в *buildSrc* директорията на прокета( в нашия слуай)
-  Всеки плъгин трябва да осигури имплементационен клас, който представлява входна точка към него. Това се извършва чрез имплементирането на интерфейса Plugin както споменах по-горе. Плъгинът може да бъде написан на всеки един *JVM* език, който може да бъде компилиран до байткод - например Java, Groovy, Scala.
-  Всеки плъгин може да бъде разширяван посредством extension обект и след това да бъде конфигуриран и така да му се промени default-ното му поведение.
-  Дескриптор за плъгина - файл, който съдържа метаинформация за разширението. Обикновенно се използва за свързване межеду краткото име на плъгина и имплементационния му клас.

#### Стъпки при създаване
В следващите абзация ще разгледаме как да създадем HelloWorld плъгин от самото начало. Избраният език за неговото създаване е Java.

1. Първо както казах е необходимо да създаде имплементационен клас. Плъгинът е Java файл разположен в 
	\Project\buildSrc\plugins\src\main\groovy\bg\uni\fmi\plugins\sample\HelloPlugin.java

		import org.gradle.api.Plugin;
		import org.gradle.api.Project;

		public class HelloPlugin implements Plugin<Project>{
		
		    @Override
		    public void apply(Project project) {
		
		    }
		}
Към неговата имплементация ще се върнем след малко.

2. Всеки плъгин е изграден от задачи, в които може да се имплементира определена логика, която лесно да се разширява. Gradle осигурява default-на имплементация, която може да се разшири (extends) - *org.gradle.api.DefaultTask*. Освен него *Gradle* предлага и други вградени имплементации като *SourceTask*, но всички те разширяват *DefaultTask*.
Нека създадем къстъмизиран task (custom task) в:

	\Project\buildSrc\plugins\src\main\groovy\bg\uni\fmi\tasks\sample\PrintContent.java
Поведението на task-a се капсулира в task action и за да се покаже, кое дейстиве да се изпълни един от методите се маркира с анотацията *@TaskAction* името на това действие може да е произволно. Поведението на действието се конфигурира посредством свойства.

3. Цялостен пример

		public class PrintContent extends DefaultTask {
	    @Input
	    private String personName;
	
	    @Input
	    @Optional
	    private String title;
	
	    @Input
	    private String salutation = "Dear";
	
	    @TaskAction
	    public void compose() {
	        System.out.println(generateMessage());
	    }
	
	    String generateMessage() {
	        return String.format("%s %s %s I just want to say hello to you.", capitalizeFirstLetter(getSalutation()), getTitle(), getPersonName());
	    }
	
	    String capitalizeFirstLetter(String word) {
	        return StringUtils.capitalize(word);
	    }
	
	    public String getTitle() {
	        return (title == null) ? "" : title;
	    }
	
	    public String getPersonName() {
	        return personName;
	    }
	    public String getSalutation() {
	        return salutation;
	    }
	
	    public void setPersonName(String personName) {
	        this.personName = personName;
	    }
	
	    public void setSalutation(String salutation) {
	        this.salutation = salutation;
	    }
	
	    public void setTitle(String title) {
	        this.title = title;
	    }
	}


Както виждате **PrintContent** наследява **DefaultTask** като дефинира действие **@TaskAction**, което носи името **compose**. Тук е важно да се наблегне, че **task**-a има три входни свойства **personName**, **title**, **salutation**, като **personName** е задължително, **title** е входно свойство, но е опционално и **salutation** е входно свойство със стойност по подразбиране, т.е. не е необходимо да се анотира с **@Optional**, защото то се подразбира и ако не се специфицира никаква стойност се взима **default**-ната - **"Dear"**

Методът анотиран като действие **compose()** извиква **generateMessage()**, който от своя страна извикава **capitalizeFirstLetter(String word)**, който използва външната библиотека **commons-lang**, поради тази причина, за да е достъпна по време на компилация тя трябва да се добави като **compile** зависимост в билд скрипт файла на дадения плъгин.

	  dependencies {
	  	compile 'commons-lang:commons-lang:2.6'
	  }

както и хранилище от където тази библиотека да се достъпи

	repositories {
	    mavenCentral()
	} 
3. Създаване на плъгин използващ нашата задача

Gradle позволява композиране и наседяване на плъгин, т.е. ако искаме нашият плъгин може да надгражда вградените в Gradle плъгини, например java, groovy плъгин, но в случая ще изградим изцяло нова приставка.

		public class HelloPlugin implements Plugin<Project> {
		    public static final String HELLO_TASK_NAME = "helloТаск";
		
		    @Override
		    public void apply(Project project) {
		        createTasks(project);
		    }
		
		    void createTasks(Project project) {
		        PrintContent helloTask = project.getTasks().create(HELLO_TASK_NAME, PrintContent.class);
		        helloTask.setDescription("Just say hello.");
		        helloTask.setGroup("Hello");
		    }
		}

Както споменах по-рано ние създаваме обектен плъгин и трябва да представим имплементация на интерфейса Project

	public class HelloPlugin implements Plugin<Project> {

метода, който трябва да имплементираме от този интерфейс е apply, който приема като единствен аргумент **Project project** иснтанция

Към нашият плъгин трябва да добавим предварително създадени custom task -ове, по своята същност те извън обхвата на плъгина не може да се изпълнят самостоятелно, за това ги добавяме към plugin обекта, където вече те се наричат Enhanced задачи и могат да бъдат конфигурирани.

- Всеки проект (**project**) съдържа контейнер( разбирайте множество от задачи **tasks**), към които можем да добавяме нови. Достъпът до този [TaskContainer](http://www.gradle.org/docs/current/javadoc/org/gradle/api/tasks/TaskContainer.html) се осъществява чрез **project.getTasks()** ,а добавянето на нова задача с метода **create**.

		<T extends Task> T	create(String name, Class<T> type)
		Creates a Task with the given name and type, and adds it to this container.

След това на новодобавения task можем да му добавим допълнителни свойства, които да подпомагат потребителя при търсенето му - description и group. 

**Забележка**: Когато на дадена задача няма дабавена group и никоя друга задача не зависи на него(depends On) то при извъплянване на командата gradle tasks той няма да се изведе( ще се изведе само при **tasks --all**)

4. Именуване

Сега вече имаме плъгин с един task в него, но как ще се използва от потребителите. Трябва да променим дескриотора за плъгина, както споменах по-горе. В противен случай потребителите трябва да го добавят като
	apply plugin: 'bg.uni.fmi.plugins.sample.HelloPlugin'

За това създаваме нов файл в :

	\Project\buildSrc\plugins\src\main\resources\META-INF\gradle-plugins\fmi-hello.properties

Като името, което ще се използва от потребителя е името на файла(без разширението) ,т.е. **fmi-hello** , а самото съдържание на файла е:

	implementation-class = bg.uni.fmi.plugins.sample.HelloPlugin

5. Използване
Тъй като сме създали приставката в buildSrc директорията при стартиране на основния проект, първо се билдва и тества съдържанието от buildSrc и се добавя към classpath на проекта, така плъгините, които сме създали са достъпни априори.



