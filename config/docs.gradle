import org.gradle.plugins.jsoup.Jsoup
import org.gradle.plugins.pegdown.PegDown
import org.gradle.plugins.xhtmlrenderer.XhtmlToPdf

apply plugin: "base"
apply plugin: "pegdown"
apply plugin: "xhtmlrenderer"
apply plugin: "jsoup"

tasks.withType(Jsoup) {
    destination "$buildDir/html/${name}.html"
    inputEncoding "utf-8"
    transform {
        outputSettings().indentAmount(2).prettyPrint(true)
    }
}

task concatPartsMd(type: FileConcatTask) {
    source(fileTree("src/main/parts") { include "*.md" })
    destination "$buildDir/parts.md"
    destination "README.md"
    joiner "\n\n"
}

task rawHtml(type: PegDown) {
    source concatPartsMd
    destination "$buildDir/html/parts-raw.html"
}

["base"].each { transformType ->
    task("${transformType}Html", type: Jsoup) { task ->
        def path = "src/main/transforms/${transformType}.groovy"

        def global = "$rootDir/$path"
        inputs.file global
        apply from: global, to: task

        doLast {
            println "Documentation is generated in:\n $buildDir/html/${name}.html"
        }

    }
}

baseHtml.source rawHtml
task copyStyles(type: Copy) {
    from 'src/main/style'
    into 'build/html/style'
}

baseHtml {
    dependsOn copyStyles
    description "Generate html userGuide for the system"
}

task pdf << {
    println "User guide pdf is generated in:\n $buildDir/userGuide.pdf"
}

pdf.dependsOn task("pdfGenerate", type: XhtmlToPdf) {
    inputs.file file("$buildDir/html/baseHtml.html")
    source "$buildDir/html/baseHtml.html"
    pdf = file("$buildDir/userGuide.pdf")
    fonts = fileTree("src/main/style/fonts") {
        include "*.ttf"
    }

}

pdf {
    dependsOn baseHtml
    description "Generate pdf userGuide for the system"
}

class FileConcatTask extends SourceTask {
    @Input
    @Optional
    String joiner

    private destination

    @OutputFile
    File getDestination() { project.file(destination) }

    void setDestination(destination) { this.destination = destination }

    @TaskAction
    void doFileConcat() {
        getDestination().withOutputStream { out ->
            getSource().files.sort { it.name }.each {
                it.withInputStream { out << it }
                if (joiner) {
                    out << joiner
                }
            }
        }
    }
}
